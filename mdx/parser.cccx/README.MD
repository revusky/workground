The grammar/parser here is a work in progress.

This directory contains a significantly refactored/improved version of the previous grammar. Much (maybe most) of the improvement is due to a greater usage of advanced features in CongoCC that were not present in the legacy JavaCC tool tool.

Actually, the previous version of this grammar did not use any of the automatic tree-building (i.e. the JJTree tool) that was even present in the older JavaCC. That meant that the author of the parser/grammar had to maintain the Java code that implemented the AST (Abstract Syntax Tree) separately. In this newer version of the grammar, we simply declare the node classes in the grammar and we can even *inject* code into them. Thus, for example, we can just *inject* API like:

     INJECT MyNode :
     {
          public List<SubNode> subNodes() {
               return childrenOfType(SubNode.class);
          }
     }

A specified requirement was that the various objects in the Congo-generated AST would implement the already existing API in org.eclipse.daanse.mdx.model.api.* but this is quite easy to achieve. For example, in the file `Expressions.inc.ccc` here is just one example:

    INJECT CompoundId : implements Expression, org.eclipse.daanse.mdx.model.api.expression.CompoundId
    {
        public java.util.List<ObjectIdentifier> objectIdentifiers() {
           return childrenOfType(ObjectIdentifier.class);
        }
    }  

Thus, you see that the `CompoundId` node generated by CongoCC can implement the `org.eclipse.daanse.mdx.model.api.expression.CompoundId` and the method that it needs to have there, `objectIdentifiers()` which has a trivial implementation, given the already existing API that is there.

That, by the way, gives some sense of how much of a win this really is. For one thing, this `CompundId`, like any generated node, has location info built into it, so you have `getBeginLine()` and `getEndLine()` and so on, or just `getLocation()` which just a string that tells you the location. This is very useful in terms of generating error messages, as opposed to just telling the user that he has an error *somewhere*!

And you automatically have an abstract `Visitor` class that you can use to *visit* a tree (or subtree).

An interesting aspect of the above code injection is that the `java.util.List<ObjectIdentifier>` that is returned by the `objectIdentifiers` method is a List of `org.eclipse.daanse.mdx.parser.cccx.tree.ObjectIdentifier` objects, not of `org.eclipse.daanse.mdx.model.api.expression.ObjectIdentifier` objects. This is possible because the API for CompoundId (I changed it a bit) now specifies:

     List<? extends ObjectIdentifier> objectIdentifiers();

instead of:

     List<ObjectIdentifier> objectIdentifiers();

It would be possible to implement the above API, just a question of specifying:

    INJECT CompoundId : implements Expression, org.eclipse.daanse.mdx.model.api.expression.CompoundId
        import org.eclipse.daanse.mdx.model.api.expression.ObjectIdentifier;
    {
        public java.util.List<ObjectIdentifier> objectIdentifiers() {
           return childrenOfType(ObjectIdentifier.class);
        }
    }

In the method would return a list of `org.eclipse.daanse.mdx.model.api.expression.ObjectIdentifier`. Of course, in reality, all of this is the same at *run-time* since Java generics work with type erasure anyway! All of these distinctions only exist at *compile-time*, not at *run-time*.

Well, there is a more general point I would make about all of this, which is that there is really no problem in terms of name clashes. For example, in the above injection, we have `public class CompoundId implements org.eclipse.daanse.mdx.model.api.expression.CompoundId`

The fact that the concrete node has the same *unqualified* name as the interface that it is implementing is not really a problem. I don't think that it tends to create much confusion really. And, of course, if there is *genuine* confusion such that the compiler cannot distinguish the two things, then the compiler will simply refuse to compile your code. All this stuff of adding magic prefixes to names does not seem to be worth the bother. It's mostly solving a non-problem. I always thought this, but this round of work has convinced me more of this. I mean, having all the concrete nodes start with AST, so you have ASTCompoundId and so on. Or having your interfaces start (or end with I or something). All of this leads to rather ugly code and doesn't solve much of a problem anyway. In any IDE or good programmer's editor, you can simply hover the mouse over any variable name and it tells you its fully qualified name.


