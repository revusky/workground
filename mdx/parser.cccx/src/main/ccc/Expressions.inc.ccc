/*
* Copyright (c) 2023 Contributors to the Eclipse Foundation.
*
* This program and the accompanying materials are made
* available under the terms of the Eclipse Public License 2.0
* which is available at https://www.eclipse.org/legal/epl-2.0/
*
* SPDX-License-Identifier: EPL-2.0
*
* Contributors:
*   SmartCity Jena - initial
*   Stefan Bischof (bipolis.org) - initial
*/

// Breaking the expression logic out into a 
// separate INCLUDE

INJECT PARSER_CLASS :
  import org.eclipse.daanse.mdx.model.api.expression.CallExpression.Type;
{
	public static Expression createCall(Expression left, ObjectIdentifier objectIdentifier,
			List<Expression> expressions) {
		final String name = objectIdentifier instanceof NameObjectIdentifier nameObjectIdentifier
				?  nameObjectIdentifier.name()
				: null;
		if (expressions != null) {
			if (left != null) {
				// Method syntax: "x.foo(arg1, arg2)" or "x.foo()"
				expressions.add(0, left);
				return new CallExpressionImpl(name, Type.METHOD, expressions);
			} else {
				// Function syntax: "foo(arg1, arg2)" or "foo()"
				return new CallExpressionImpl(name, Type.FUNCTION, expressions);
			}
		} else {
			// Member syntax: "foo.bar"
			// or property syntax: "foo.RESERVED_WORD"
			Type type;
			boolean call = false;
			switch (objectIdentifier.quoting()) {
			case UNQUOTED:
				type = Type.PROPERTY;
				call = true;
				break;
			case QUOTED:
				type = Type.PROPERTY_QUOTED;
				break;
			default:
				type = Type.PROPERTY_AMPERS_AND_QUOTED;
				break;
			}
			if (!call && left instanceof CompoundId compoundIdLeft) {
        CompoundId result = new CompoundId();
        for (ObjectIdentifier oi : compoundIdLeft.objectIdentifiers()) {
           result.addChild(oi);
        }
        result.addChild((Node) objectIdentifier);
        return result;
			} else if (left == null) {
        return new CompoundId(objectIdentifier);
			} else {
				return new CallExpressionImpl(name, type, List.of(left));
			}
		}
	}

  public static class CallExpressionImpl extends NODE_PACKAGE.BaseNode implements Expression, org.eclipse.daanse.mdx.model.api.expression.CallExpression {
      private String name;
      private Type type;
      List<? extends Expression> expressions;
      public CallExpressionImpl(String name,
                                Type type,
                                List<? extends Expression> expressions) 
      {
         assert name != null;
         assert type != null;
         assert expressions != null;

         this.name = name;
         this.type = type;
         this.expressions = expressions;
         switch (type) {
            case BRACES:
                assert name.equals("{}");
                break;
            case PARENTHESES:
                assert name.equals("()");
                break;
            case INTERNAL:
                assert name.startsWith("$");
                break;
            case EMPTY:
                assert name.equals("");
                break;
            default:
                assert !name.startsWith("$") && !name.equals("{}") && !name.equals("()");
                break;
         }
      }

      public String name() {return name;}
      public Type type() { return type;}
      public List<? extends Expression>  expressions() {return expressions;}
  }
}

INJECT Expression : extends org.eclipse.daanse.mdx.model.api.expression.Expression

Expression Expression#interface :
{
  Expression expression;
  ObjectIdentifier objectIdentifier;
}
  expression = parseUnaliasedExpression
  (
    < AS > 
    objectIdentifier = ObjectIdentifier
    {
      CompoundId compoundId = new CompoundId(objectIdentifier);
      expression = new PARSER_CLASS.CallExpressionImpl("AS", Type.TERM_INFIX, List.of(
      expression, compoundId
      )
      );
    }
  )*
  {
    return expression;
  }
;


Expression parseExpressionOrEmpty :
{
  Expression expression;
}
  expression = Expression
  {
    return expression;
  }
  | /* empty */
  {
    return new PARSER_CLASS.CallExpressionImpl("", Type.EMPTY, List.of());
  }
;

// List of expressions, none of which may be empty.
List < Expression > expList :
{
  Expression expression;
  List < Expression > list = new LinkedList<>();
}
  expression = Expression
  {
    list.add(expression);
  }
  (
    < COMMA >
    expression = Expression
    {
      list.add(expression);
    }
  )*
  {
    return list;
  }
;


Expression parseExpressionEof :
{
  Expression expression;
}
  expression = Expression < EOF >
  {
    return expression;
  } 
;

INJECT interface ObjectIdentifier : extends Expression, org.eclipse.daanse.mdx.model.api.expression.ObjectIdentifier

ObjectIdentifier ObjectIdentifier#interface :
{
  ObjectIdentifier objectIdentifier;
}
  (
    objectIdentifier = NameObjectIdentifier
    |
    objectIdentifier = KeyObjectIdentifier
  )
  {
    return objectIdentifier;
  }
;

INJECT interface NameObjectIdentifier : 
    extends ObjectIdentifier, 
            org.eclipse.daanse.mdx.model.api.expression.NameObjectIdentifier,
            org.eclipse.daanse.mdx.model.api.expression.SymbolLiteral

NameObjectIdentifier#interface :
  // It seems that some reserved words can act as identifiers under
  // some considerations, but of course, that is what the [...] is for, no?
  // This only seems to exist in the Pentaho grammar. REVISIT
  //parseKeyword 
  //|
  < ID > 
  |
  // Neither the Microsoft spec the Oracle spec makes any mention of this!  
  < AT_ID > 
  | 
  < QUOTED_ID >
;


INJECT KeyObjectIdentifier :
   import java.util.List;
   import java.util.ArrayList;
   implements ObjectIdentifier, org.eclipse.daanse.mdx.model.api.expression.KeyObjectIdentifier
{
   public List<NameObjectIdentifier> nameObjectIdentifiers() {
     return childrenOfType(NameObjectIdentifier.class);
   }

   @Override
   public Quoting quoting() {
       return Quoting.KEY;
   }
}

// for example '&foo&[1]&bar' in '[x].&foo&[1]&bar.[y]'
KeyObjectIdentifier :
  ( <AMP_QUOTED_ID> | <AMP_UNQUOTED_ID> )+
;


INJECT CompoundId : implements Expression, org.eclipse.daanse.mdx.model.api.expression.CompoundId
{
    public CompoundId() {super();}

    public CompoundId(ObjectIdentifier id) {
      super();
      addChild(id);
    }

    public java.util.List<ObjectIdentifier> objectIdentifiers() {
       return childrenOfType(ObjectIdentifier.class);
    }
}  

CompoundId :
  ObjectIdentifier
  (
    < DOT > ObjectIdentifier
  )*
;

Expression parseUnaliasedExpression :
{
  Expression x;
  Expression y;
}
  x = parseTerm5
  (
    < OR > y = parseTerm5
    {
      x = new PARSER_CLASS.CallExpressionImpl("OR", Type.TERM_INFIX, List.of(
      x, y
      )
      );
    }
    | 
    < XOR > y = parseTerm5
    {
      x = new PARSER_CLASS.CallExpressionImpl("XOR", Type.TERM_INFIX, List.of(
      x, y
      )
      );
    }
    |
    // range 'm1 : m2' yields set of members
    < COLON > y = parseTerm5
    {
      x = new PARSER_CLASS.CallExpressionImpl(":", Type.TERM_INFIX, List.of(
      x, y
      )
      );
    }
  )*
  {
    return x;
  }
;


Expression parseTerm5 :
{
  Expression x;
  Expression y;
}
  x = parseTerm4
  (
    < AND > y = parseTerm4
    {
      x = new PARSER_CLASS.CallExpressionImpl("AND", Type.TERM_INFIX, List.of(
      x, y
      )
      );
    }
  )*
  {
    return x;
  }
;


Expression parseTerm4 :
{
  Expression x;
}
  x = parseTerm3
  {
    return x;
  }
  | 
  < NOT > x = parseTerm4
  {
    return new PARSER_CLASS.CallExpressionImpl("NOT", Type.TERM_PREFIX, List.of(
    x
    )
    );
  }
;


Expression parseTerm3 :
{
  Expression x;
  Expression y;
  Token op;
}
  AdditiveExpression {x = (Expression) peekNode();}
  (
    // e.g. "1 < 5"
    (
      < EQ >
      {
        op = getToken(0);
      }
    | < NE >
      {
        op = getToken(0);
      }
    | < LT >
      {
        op = getToken(0);
      }
    | < GT >
      {
        op = getToken(0);
      }
    | < LE >
      {
        op = getToken(0);
      }
    | < GE >
      {
        op = getToken(0);
      }
    )
    AdditiveExpression {y = (Expression) peekNode();}
    {
      x = new PARSER_CLASS.CallExpressionImpl(op.getImage(), Type.TERM_INFIX, List.of(
      x, y
      )
      );
    }
    |
    // We expect a shift-reduce conflict here, because NULL is a literal and
    // so is a valid argument to the IS operator. We want to shift.
    SCAN 2 =>
    < IS > < NULL >
    {
      x = new PARSER_CLASS.CallExpressionImpl("IS NULL", Type.TERM_POSTFIX, List.of(
      x
      )
      );
    }
    |
    // e.g. "x IS y"; but "x IS NULL" is handled elsewhere
    SCAN 2 =>
    < IS > 
    AdditiveExpression {y = (Expression) peekNode();}
    {
      x = new PARSER_CLASS.CallExpressionImpl("IS", Type.TERM_INFIX, List.of(
      x, y
      )
      );
    }
    | < IS > < EMPTY >
    {
      x = new PARSER_CLASS.CallExpressionImpl(
      "IS EMPTY", Type.TERM_POSTFIX, List.of(x));
    }
  | < MATCHES > 
    AdditiveExpression {y=(Expression) peekNode();}
    {
      x = new PARSER_CLASS.CallExpressionImpl("MATCHES", Type.TERM_INFIX, List.of(
      x, y
      )
      );
    }
  | SCAN 2 =>
    < NOT > < MATCHES > 
    AdditiveExpression {y = (Expression )peekNode();}
    {
      x = new PARSER_CLASS.CallExpressionImpl(
      "NOT", Type.TERM_PREFIX, List.of(
      new PARSER_CLASS.CallExpressionImpl(
      "MATCHES", Type.TERM_INFIX, List.of(
      x, y
      )
      )
      )
      );
    }
  | < IN > 
    AdditiveExpression {y = (Expression) peekNode();}
    {
      x = new PARSER_CLASS.CallExpressionImpl("IN", Type.TERM_INFIX, List.of(
      x, y
      )
      );
    }
    | < NOT > < IN > 
    AdditiveExpression {y = (Expression) peekNode();}
    {
      x = new PARSER_CLASS.CallExpressionImpl(
      "NOT", Type.TERM_PREFIX, List.of(
      new PARSER_CLASS.CallExpressionImpl(
      "IN", Type.TERM_INFIX, List.of(
      x, y
      )
      )
      )
      );
    }
  )*
  {
    return x;
  }
;

INJECT AdditiveExpression :
    import java.util.List;
    implements Expression, org.eclipse.daanse.mdx.model.api.expression.CallExpression
{
    public String name() {
       return getChild(1).getImage();
    }

    public Type type() {
       return Type.TERM_INFIX; 
    }

    public List<Expression> expressions() {
        return List.of((Expression) getChild(0), (Expression) getChild(2));
    }
}


AdditiveExpression#(>1) :
  MultiplicativeExpression
  (
    (
     <PLUS>
     |
     <MINUS>
     |
     // Only seeems yo be in Pentaho
     <CONCAT>
    )
    MultiplicativeExpression
  )*
;

INJECT MultiplicativeExpression :
    import java.util.List;
    implements Expression, org.eclipse.daanse.mdx.model.api.expression.CallExpression
{
    public String name() {
       return getChild(1).getImage();
    }

    public Type type() {
       return Type.TERM_INFIX; 
    }

    public List<Expression> expressions() {
        return List.of((Expression) getChild(0), (Expression) getChild(2));
    }
}    

MultiplicativeExpression#(>1) :
  UnaryExpression
  (
    (<ASTERISK>|<SOLIDUS>) 
    UnaryExpression
  )*
;

INJECT UnaryExpression : 
    import java.util.List;
    implements Expression, org.eclipse.daanse.mdx.model.api.expression.CallExpression
{
    public String name() {
       return getChild(0).getImage();
    }

    public Type type() {
       return Type.TERM_PREFIX; 
    }

    public List<Expression> expressions() {
        return List.of((Expression) getChild(1));
    }

}

UnaryExpression#(>1) :
    (
      <PLUS>
      |
      <MINUS>
      |
      // This is only in Pentaho, it seems.
      <EXISTING>
    )?
    PrimaryExpression
;    

INJECT PrimaryExpression : extends Expression

PrimaryExpression#interface :
    AtomicExpression
    (
      (< DOT > ObjectIdentifier) #DotName(+1)
      (
        (
          < LPAREN > 
          (Expression)?
          (< COMMA > (Expression)?)*
          < RPAREN >
        ) #FunctionCall(+1)
      )?
    )*
;

INJECT DotName : 
    implements PrimaryExpression, org.eclipse.daanse.mdx.model.api.expression.CallExpression
{
    public String name() {
        return getChild(2) instanceof NameObjectIdentifier noi ? noi.name() : null;
    }

    public Type type() {
       ObjectIdentifier oi = (ObjectIdentifier) getChild(2);
       return switch (oi.quoting()) {
			    case UNQUOTED -> Type.PROPERTY;
			    case QUOTED -> Type.PROPERTY_QUOTED;
          default-> Type.PROPERTY_AMPERS_AND_QUOTED;
			 };       
    }

    public java.util.List<Expression> expressions() {
       return childrenOfType(Expression.class);
    }
}    
  
INJECT FunctionCall : 
    import java.util.List;
    import java.util.ArrayList;
    implements PrimaryExpression, org.eclipse.daanse.mdx.model.api.expression.CallExpression
{
    public String name() {
        return getChild(2) instanceof NameObjectIdentifier noi ? noi.name() : null;
    }

    public Type type() {
       return expressions().size() > 1 ? Type.FUNCTION : Type.METHOD;
    }

    public List<Expression> expressions() {
       List<Expression> result = new ArrayList<>();
       result.add((Expression) getChild(0));
       for (int i = 1; i < getChildCount(); i++) {
          Node child = getChild(i);
          if (child instanceof Expression e) result.add(e);
          else if (child.getType() == COMMA) {
            // REVISIT maybe should use something instead of null
             if (!(child.previousSibling() instanceof Expression)) {
                result.add(null);
             }
             if (child.nextSibling().getType()==RPAREN) result.add(null);
          }
       }
       return result;
    }
}    
      
INJECT interface Literal : extends AtomicExpression, org.eclipse.daanse.mdx.model.api.expression.Literal

Literal#interface :
    <STRING_LITERAL>
    |
    <UNSIGNED_INTEGER_LITERAL>
    |
    <DECIMAL_NUMERIC_LITERAL>
    |
    <APPROX_NUMERIC_LITERAL>
    |
    <NULL>
;

INJECT CastExpression :
    import java.util.List;
    import java.util.ArrayList;
    import org.eclipse.daanse.mdx.model.api.expression.Expression;
    implements AtomicExpression, org.eclipse.daanse.mdx.model.api.expression.CallExpression
{
    @Property Expression expression;

    public String name() {
      return "CAST";
    }

    public Type type() {
      return Type.CAST;
    }

    public List<Expression> expressions() {
        List<Expression> result = new ArrayList<>();
        result.add(getExpression());
        result.add((Expression) firstChildOfType(NameObjectIdentifier.class));
        return result;
      }
}

  CastExpression :
  {
    Expression expression;
  }
    <CAST>
    <LPAREN>
    expression = parseUnaliasedExpression
    {CURRENT_NODE.setExpression(expression);}
    <AS>
    NameObjectIdentifier 
    <RPAREN>
  ;

  Expression parseExpressionList#void :
  {
    List<Expression> expressions;
  }
    < LPAREN > expressions = expList < RPAREN >
    {
      // Whereas ([Sales],[Time]) and () are tuples, ([Sales]) and (5)
      // are just expressions.
      return new PARSER_CLASS.CallExpressionImpl(
      "()", Type.PARENTHESES, expressions);
    }
  ;

  INJECT Tuple : implements AtomicExpression

  Expression Tuple :
  {
    List<Expression> expressions;
  }
    // set built from sets/tuples
    < LBRACE >
    (
      SCAN < RBRACE > =>
      {
        expressions = Collections.emptyList();
      }
      |
      expressions = expList
    )
    < RBRACE >
    {
      return new PARSER_CLASS.CallExpressionImpl(
      "{}", Type.BRACES, expressions);
    }
  ;

  Expression OnlyName#void :
    NameObjectIdentifier ASSERT ~(<BANG>|<LPAREN>) =>||
    {
        return (Expression) peekNode();
    }
  ;

  Expression parseMaybeBangMaybeFunctionCall#void :
    // Function call "foo(a, b)" or "whiz!bang!foo(a, b)".
    // Properties "x.PROP" and methods "exp.meth(a)" are in primary().
  {
    Expression expression;
    NameObjectIdentifier nameObjectIdentifier;
    List < Expression > expressions = null;
  }
    nameObjectIdentifier = NameObjectIdentifier
    (
      < BANG > 
      nameObjectIdentifier = NameObjectIdentifier
      {
      // We support the syntax for qualifying function names with package
      // names separated by bang ('!'), e.g. 'whiz!bang!foo(a, b)'
      // but currently we ignore the qualifiers. The previous example is
      // equivalent to 'foo(a, b)'.
      }
    )*
    (
      < LPAREN >
      (
        SCAN < RPAREN > =>
        {
          expressions = Collections.emptyList();
        }
        |
        expressions = expOrEmptyList
      )
      < RPAREN >
    )?
    {
      return createCall(null, nameObjectIdentifier, expressions);
    }
  ;

  
// Comma-separated list of expressions, some of which may be empty. Used
// for functions.
List < Expression > expOrEmptyList :
{
  Expression expression;
  List < Expression > list = new LinkedList<>();
}
  expression = parseExpressionOrEmpty
  {
    list.add(expression);
  }
  (
    < COMMA >
    expression = parseExpressionOrEmpty
    {
      list.add(expression);
    }
  )*
  {
    return list;
  }
;



INJECT AtomicExpression : extends PrimaryExpression

AtomicExpression#interface :
      Literal 
      | 
      CastExpression
      |
      parseExpressionList
      | 
      Tuple 
      | 
      CaseExpression 
      |
      OnlyName 
      |
      parseMaybeBangMaybeFunctionCall
;

INJECT CaseExpression : implements AtomicExpression 

Expression CaseExpression :
{
    Expression expression, expression2;
    List < Expression > expressions = new ArrayList <> ();
    boolean match = false;
}
    < CASE >
    (
      expression = Expression
      {
        match = true;
        expressions.add(expression);
      }
    )?
    (
      < WHEN > expression = Expression < THEN > expression2 = Expression
      {
        expressions.add(expression);
        expressions.add(expression2);
      }
    )*
    (
      < ELSE > expression = Expression
      {
        expressions.add(expression);
      }
    )?
    < END >
    {
      if (match)
      {
        return new PARSER_CLASS.CallExpressionImpl(
        "_CaseMatch", Type.TERM_CASE, expressions);
      }
      else
      {
        return new PARSER_CLASS.CallExpressionImpl(
        "_CaseTest", Type.TERM_CASE, expressions);
      }
    }
;

INJECT FormulaExpression : implements org.eclipse.daanse.mdx.model.api.expression.FormulaExpression;

FormulaExpression parseFormulaExpression#FormulaExpression :
    ObjectIdentifier < EQ > ObjectIdentifier
    {
      return CURRENT_NODE;
    }
;

  INJECT MemberPropertyDefinition :
    implements org.eclipse.daanse.mdx.model.api.select.MemberPropertyDefinition
  {
    public ObjectIdentifier objectIdentifier() {
        return (ObjectIdentifier) getChild(0);
   }

   public Expression expression() {
      return (Expression) getChild(2);
   }
}

MemberPropertyDefinition :
  ObjectIdentifier 
  < EQ > 
  Expression
;

