/*
* Copyright (c) 2023 Contributors to the Eclipse Foundation.
*
* This program and the accompanying materials are made
* available under the terms of the Eclipse Public License 2.0
* which is available at https://www.eclipse.org/legal/epl-2.0/
*
* SPDX-License-Identifier: EPL-2.0
*
* Contributors:
*   SmartCity Jena - initial
*   Stefan Bischof (bipolis.org) - initial
*/

// https://docs.oracle.com/cd/E57185_01/ESBTR/mdx_syn_gram.html
// https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms717923(v=vs.85)
BASE_NAME = Mdx;
IGNORE_CASE = true;
PARSER_PACKAGE = org.eclipse.daanse.mdx.parser.cccx;
NODE_PACKAGE = org.eclipse.daanse.mdx.parser.cccx.tree;
TABS_TO_SPACES = 4;
NODE_PREFIX = "AST";
ENSURE_FINAL_EOL;
COPYRIGHT_BLURB="\n*\n* Copyright (c) 2023 Contributors to the Eclipse Foundation.\n*\n* This program and the accompanying materials are made\n* available under the terms of the Eclipse Public License 2.0\n* which is available at https://www.eclipse.org/legal/epl-2.0/\n*\n* SPDX-License-Identifier: EPL-2.0\n*\n* Contributors: see corresponding .ccc file\n";

INJECT PARSER_CLASS :
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Optional;
import java.util.concurrent.CancellationException;

import org.eclipse.daanse.mdx.model.api.DrillthroughStatement;
import org.eclipse.daanse.mdx.model.api.ExplainStatement;
import org.eclipse.daanse.mdx.model.api.MdxStatement;
import org.eclipse.daanse.mdx.model.api.SelectStatement;
import org.eclipse.daanse.mdx.model.api.RefreshStatement;
import org.eclipse.daanse.mdx.model.api.ReturnItem;
import org.eclipse.daanse.mdx.model.api.DMVStatement;
import org.eclipse.daanse.mdx.model.api.expression.CallExpression;
import org.eclipse.daanse.mdx.model.api.expression.CompoundId;
import org.eclipse.daanse.mdx.model.api.expression.Expression;
import org.eclipse.daanse.mdx.model.api.expression.FormulaExpression;
import org.eclipse.daanse.mdx.model.api.expression.KeyObjectIdentifier;
import org.eclipse.daanse.mdx.model.api.expression.NameObjectIdentifier;
import org.eclipse.daanse.mdx.model.api.expression.ObjectIdentifier;
import org.eclipse.daanse.mdx.model.api.select.Axis;
import org.eclipse.daanse.mdx.model.api.select.CreateCellCalculationBodyClause;
import org.eclipse.daanse.mdx.model.api.select.CreateMemberBodyClause;
import org.eclipse.daanse.mdx.model.api.select.CreateSetBodyClause;
import org.eclipse.daanse.mdx.model.api.select.MemberPropertyDefinition;
import org.eclipse.daanse.mdx.model.api.select.SelectCellPropertyListClause;
import org.eclipse.daanse.mdx.model.api.select.SelectDimensionPropertyListClause;
import org.eclipse.daanse.mdx.model.api.select.SelectQueryAsteriskClause;
import org.eclipse.daanse.mdx.model.api.select.SelectQueryAxesClause;
import org.eclipse.daanse.mdx.model.api.select.SelectQueryAxisClause;
import org.eclipse.daanse.mdx.model.api.select.SelectQueryClause;
import org.eclipse.daanse.mdx.model.api.select.SelectSlicerAxisClause;
import org.eclipse.daanse.mdx.model.api.select.SelectSubcubeClause;
import org.eclipse.daanse.mdx.model.api.select.SelectSubcubeClauseName;
import org.eclipse.daanse.mdx.model.api.select.SelectSubcubeClauseStatement;
import org.eclipse.daanse.mdx.model.record.expression.CallExpressionR;
import org.eclipse.daanse.mdx.model.record.expression.CompoundIdR;
{
	public static String stripQuotes(String s, String prefix, String suffix, String quoted) {
		if (!(s.startsWith(prefix) && s.endsWith(suffix))) {
            throw new IllegalArgumentException("Invalid quotes: " + s);
        }
		s = s.substring(prefix.length(), s.length() - suffix.length());
		s = s.replace(quoted, suffix);
		return s;
	}

	public static Expression createCall(Expression left, ObjectIdentifier objectIdentifier,
			List<Expression> expressions) {
		final String name = objectIdentifier instanceof NameObjectIdentifier nameObjectIdentifier
				?  nameObjectIdentifier.name()
				: null;
		if (expressions != null) {
			if (left != null) {
				// Method syntax: "x.foo(arg1, arg2)" or "x.foo()"
				expressions.add(0, left);
				return new CallExpressionR(name, CallExpression.Type.METHOD, expressions);
			} else {
				// Function syntax: "foo(arg1, arg2)" or "foo()"
				return new CallExpressionR(name, CallExpression.Type.FUNCTION, expressions);
			}
		} else {
			// Member syntax: "foo.bar"
			// or property syntax: "foo.RESERVED_WORD"
			CallExpression.Type type;
			boolean call = false;
			switch (objectIdentifier.quoting()) {
			case UNQUOTED:
				type = CallExpression.Type.PROPERTY;
				call = true;
				break;
			case QUOTED:
				type = CallExpression.Type.PROPERTY_QUOTED;
				break;
			default:
				type = CallExpression.Type.PROPERTY_AMPERS_AND_QUOTED;
				break;
			}
			if (left instanceof CompoundId compoundIdLeft && !call) {
				List<ObjectIdentifier> newObjectIdentifiers = new ArrayList<>(
						(compoundIdLeft).objectIdentifiers());
				newObjectIdentifiers.add(objectIdentifier);
				return new CompoundIdR(newObjectIdentifiers);
			} else if (left == null) {
				return new CompoundIdR(List.of(objectIdentifier));
			} else {
				return new CallExpressionR(name, type, List.of(left));
			}
		}
	}
}

INCLUDE "Lexer.ccc"


// ----------------------------------------------------------------------------
// MDX Statement
//
// <statement> ::= <selectStatement>
//                   | <drillthroughStatement>
//                   | <explainStatement>
//
// <selectStatement> ::= [WITH <formulaSpecification>]
//                         SELECT [<SelectQueryAxisClause>
//                                [, <SelectQueryAxisClause>...]]
//                         FROM [<cubeSpecification>]
//                         [WHERE <slicerSpecification>]
//                         [<cellProps>]
//
// <drillthroughStatment> ::=
//     DRILLTHROUGH
//     [ MAXROWS <count> ]
//     [ FIRSTROWSET <count> ]
//     <selectStatement>
//     [ RETURN <memberOrAttribute> [, <memberOrAttribute>...] ]
//
// <explainStatement> ::=
//     EXPLAIN PLAN FOR ( <selectStatement> | <drillthroughStatement> )
//
MdxStatement parseMdxStatement#Root :
  (
    parseSelectStatement
  	|
  	parseDrillthroughStatement
    |
    parseExplainStatement
  )
  {MdxStatement result = (MdxStatement) peekNode();} 
  < EOF >
  {
    return result;
  }
;

INJECT ASTDrillthroughStatement :
   import java.util.List;
   import java.util.Optional;
   import org.eclipse.daanse.mdx.model.api.ReturnItem;
   import org.eclipse.daanse.mdx.model.api.SelectStatement;
   implements org.eclipse.daanse.mdx.model.api.DrillthroughStatement
{
   public Optional<Integer> maxRows() {
      Node maxRows = firstChildOfType(MAXROWS);
      return maxRows == null ? Optional.empty() 
                             : Optional.of(Integer.valueOf(maxRows.nextSibling().getImage()));
   }

   public Optional<Integer> firstRowSet() {
      Node firstRow = firstChildOfType(FIRSTROWSET);
      return firstRow == null ? Optional.empty() 
                              : Optional.of(Integer.valueOf(firstRow.nextSibling().getImage()));
   }

   public SelectStatement selectStatement() {
      return firstChildOfType(SelectStatement.class);
   }

   public List<ReturnItem> returnItems() {
      return childrenOfType(ReturnItem.class);
   }
}   

DrillthroughStatement parseDrillthroughStatement#DrillthroughStatement :
  < DRILLTHROUGH >
  (
    < MAXROWS > < UNSIGNED_INTEGER_LITERAL >
  )?
  (
    < FIRSTROWSET > < UNSIGNED_INTEGER_LITERAL >
  )?
  parseSelectStatement
  (
    < RETURN >
    parseReturnItem 
    (
      <COMMA> 
      parseReturnItem 
    )*
  )?
  {
    return CURRENT_NODE;
  }
;

// This is not used in the parser. I just re-added this methods
// so that a pre-existing test still compiles
List<ReturnItem> parseReturnItems#ReturnItems :
   {List<ReturnItem> result = new ArrayList<>();} 
   parseReturnItem
   {result.add((ReturnItem) peekNode());}
   (<COMMA> parseReturnItem {result.add((ReturnItem) peekNode());})*
   {
    return result;
   }
;

INJECT ASTExplainStatement :
   import org.eclipse.daanse.mdx.model.api.MdxStatement;
   implements org.eclipse.daanse.mdx.model.api.ExplainStatement
{
    public MdxStatement mdxStatement() {
      return firstChildOfType(MdxStatement.class);
    }
}

ExplainStatement parseExplainStatement#ExplainStatement :
  < EXPLAIN > < PLAN> < FOR >
  (
    parseSelectStatement
    |
    parseDrillthroughStatement
  )
  {
    return CURRENT_NODE;
  }
;

INJECT ASTReturnItem :
  import org.eclipse.daanse.mdx.model.api.expression.CompoundId;
  implements org.eclipse.daanse.mdx.model.api.ReturnItem
{
   public CompoundId compoundId() {
     return (CompoundId) getChild(0);
   }
}

parseReturnItem#ReturnItem : parseCompoundId ;

INJECT ASTCreateCellCalculationBodyClause : implements org.eclipse.daanse.mdx.model.api.select.CreateCellCalculationBodyClause;

//https://learn.microsoft.com/en-us/sql/mdx/mdx-data-definition-create-cell-calculation?view=sql-server-ver16
parseCreateCellCalculationBodyClause#CreateCellCalculationBodyClause:
 <NOT><NOT><NOT><NOT><NOT><NOT><NOT>
;

INJECT ASTMeasureBodyClause : implements org.eclipse.daanse.mdx.model.api.select.MeasureBodyClause;

// https://learn.microsoft.com/en-us/analysis-services/multidimensional-models/mdx/mdx-building-measures?view=asallproducts-allversions
parseMeasureBodyClause#MeasureBodyClause:
  <NOT><NOT><NOT><NOT><NOT><NOT><NOT>
;


// https://docs.oracle.com/cd/E57185_01/ESBTR/mdx_grammar_rules.html
parseSelectWithClause#void :
  ( <CELL> <CALCULATION> parseCreateCellCalculationBodyClause
  | ("CALCULATED")? < MEMBER > parseCreateMemberBodyClause
  | < SET > parseCreateSetBodyClause
  | <MEASURE>  parseMeasureBodyClause
  )
;

INJECT ASTSelectStatement :
   import java.util.List;
   import java.util.Optional;
   import org.eclipse.daanse.mdx.model.api.select.SelectWithClause;
   import org.eclipse.daanse.mdx.model.api.select.SelectQueryClause;
   import org.eclipse.daanse.mdx.model.api.select.SelectSubcubeClause;
   import org.eclipse.daanse.mdx.model.api.select.SelectSlicerAxisClause;
   import org.eclipse.daanse.mdx.model.api.select.SelectCellPropertyListClause;
   implements org.eclipse.daanse.mdx.model.api.SelectStatement;
{
    public List<SelectWithClause> selectWithClauses() {
        return childrenOfType(SelectWithClause.class);
    } 

    public SelectQueryClause selectQueryClause() {
        return firstChildOfType(SelectQueryClause.class);
    }

    public SelectSubcubeClause selectSubcubeClause() {
        return firstChildOfType(SelectSubcubeClause.class);
    }

    public Optional<SelectSlicerAxisClause> selectSlicerAxisClause() {
        return Optional.ofNullable(firstChildOfType(SelectSlicerAxisClause.class));
    };

    public Optional<SelectCellPropertyListClause> selectCellPropertyListClause() {
        return Optional.ofNullable(firstChildOfType(SelectCellPropertyListClause.class));
    };   
}

//https://learn.microsoft.com/en-us/sql/mdx/mdx-data-manipulation-select?view=sql-server-ver16
SelectStatement parseSelectStatement#SelectStatement :
  (
    < WITH > (parseSelectWithClause)+
  )?
  < SELECT >
  (
    parseSelectQueryAsteriskClause
    |
    parseSelectQueryAxesClause
  )?
  < FROM > 
  parseSelectSubcubeClause
  (
    parseSelectSlicerAxisClause
  )?
  (
    parseSelectCellPropertyListClause
  )?
  {
     return CURRENT_NODE;
  }
;


parseSelectSubcubeClause#void :
  parseSelectSubcubeClauseName
  |
  parseSelectSubcubeClauseStatement
;


INJECT ASTSelectSubcubeClauseName :
   import org.eclipse.daanse.mdx.model.api.expression.NameObjectIdentifier;
   implements org.eclipse.daanse.mdx.model.api.select.SelectSubcubeClauseName
{
   public NameObjectIdentifier cubeName() {
      return (NameObjectIdentifier) getChild(0);
   }
}   

SelectSubcubeClauseName parseSelectSubcubeClauseName#SelectSubcubeClauseName :
  parseNameObjectIdentifier
  {
    return CURRENT_NODE;
  }
;


INJECT ASTSelectSubcubeClauseStatement :
  import java.util.Optional;
  import org.eclipse.daanse.mdx.model.api.select.SelectQueryClause;
  import org.eclipse.daanse.mdx.model.api.select.SelectSubcubeClause;
  import org.eclipse.daanse.mdx.model.api.select.SelectSlicerAxisClause;
  implements org.eclipse.daanse.mdx.model.api.select.SelectSubcubeClauseStatement
{
    public SelectQueryClause selectQueryClause() {
        return firstChildOfType(SelectQueryClause.class);
    }

    public SelectSubcubeClause selectSubcubeClause() {
        return firstChildOfType(SelectSubcubeClause.class);
    }

    public Optional<SelectSlicerAxisClause> selectSlicerAxisClause() {
      return Optional.ofNullable(firstChildOfType(SelectSlicerAxisClause.class));
    }
}  


parseSelectSubcubeClauseStatement#SelectSubcubeClauseStatement :
  < LPAREN > 
  < SELECT >
  (
    parseSelectQueryAsteriskClause
    |
    parseSelectQueryAxesClause
  )?
  < FROM > 
  parseSelectSubcubeClause
  (
    parseSelectSlicerAxisClause
  )?
  < RPAREN >
;

INJECT ASTSelectQueryAsteriskClause : implements org.eclipse.daanse.mdx.model.api.select.SelectQueryAsteriskClause;

parseSelectQueryAsteriskClause#SelectQueryAsteriskClause :
  < ASTERISK >
;


INJECT ASTSelectQueryAxesClause :
   import java.util.List;
   import org.eclipse.daanse.mdx.model.api.select.SelectQueryAxisClause;
   implements org.eclipse.daanse.mdx.model.api.select.SelectQueryAxesClause
{
   public List<SelectQueryAxisClause> selectQueryAxisClauses() {
      return childrenOfType(SelectQueryAxisClause.class);
   }
}   

SelectQueryAxesClause parseSelectQueryAxesClause#SelectQueryAxesClause :
  parseSelectQueryAxisClause
  (
    < COMMA > 
    parseSelectQueryAxisClause
  )*
  {
    return CURRENT_NODE;
  }
;


INJECT ASTSelectSlicerAxisClause :
   import org.eclipse.daanse.mdx.model.api.expression.Expression;
   implements org.eclipse.daanse.mdx.model.api.select.SelectSlicerAxisClause;
{
    public Expression expression() {
      return (Expression) getChild(1);
    }
}

parseSelectSlicerAxisClause#SelectSlicerAxisClause :
  < WHERE > 
  parseExpression
;


INJECT ASTSelectCellPropertyListClause :
   import java.util.List;
   import java.util.ArrayList;
   import java.util.stream.Collectors;
   implements org.eclipse.daanse.mdx.model.api.select.SelectCellPropertyListClause
{
   public boolean cell() {
      return getChild(0).getType() == CELL;
   }

   public List<String> properties() {
       return childrenOfType(ID).stream().map(n->n.getImage()).collect(Collectors.toList());
   }
}

SelectCellPropertyListClause parseSelectCellPropertyListClause#SelectCellPropertyListClause :
  (< CELL >)?
  < PROPERTIES > 
  <ID>
  (
    < COMMA > <ID>
  )*
  {
    return CURRENT_NODE;
  }
;

INJECT ASTCreateMemberBodyClause :
  import java.util.List;
  import java.util.ArrayList;
  import org.eclipse.daanse.mdx.model.api.expression.Expression;
  import org.eclipse.daanse.mdx.model.api.expression.CompoundId;
  import org.eclipse.daanse.mdx.model.api.select.MemberPropertyDefinition;
  implements org.eclipse.daanse.mdx.model.api.select.CreateMemberBodyClause
{
  public CompoundId compoundId() {
    return (CompoundId) getChild(0);
  }

  public Expression expression() {
     return (Expression) getChild(2);
  }

  public List<MemberPropertyDefinition> memberPropertyDefinitions() {
     return childrenOfType(MemberPropertyDefinition.class);
  }
}  

// https://learn.microsoft.com/en-us/sql/mdx/mdx-data-definition-create-member?view=sql-server-ver16
CreateMemberBodyClause parseCreateMemberBodyClause#CreateMemberBodyClause :
  parseCompoundId 
  < AS > 
  parseExpression
    (
     < COMMA > parseMemberPropertyDefinition
    )*
  {
    return CURRENT_NODE;
  }
;

INJECT ASTCreateMemberBodyClause :
  implements org.eclipse.daanse.mdx.model.api.select.CreateMemberBodyClause;
{

}  

INJECT ASTMemberPropertyDefinition :
  import org.eclipse.daanse.mdx.model.api.expression.Expression;
  import org.eclipse.daanse.mdx.model.api.expression.ObjectIdentifier;
  implements org.eclipse.daanse.mdx.model.api.select.MemberPropertyDefinition
{
   public ObjectIdentifier objectIdentifier() {
      return (ObjectIdentifier) getChild(0);
   }

   public Expression expression() {
      return (Expression) getChild(2);
   }
}

MemberPropertyDefinition parseMemberPropertyDefinition#MemberPropertyDefinition :
  parseIdentifier 
  < EQ > 
  parseExpression
  {
     return CURRENT_NODE;
  }
;

INJECT ASTFormulaExpression : implements org.eclipse.daanse.mdx.model.api.expression.FormulaExpression;

FormulaExpression parseFormulaExpression#FormulaExpression :
  parseIdentifier < EQ > parseIdentifier
  {
    return CURRENT_NODE;
  }
;

Expression parseExpression :
{
  Expression expression;
  ObjectIdentifier objectIdentifier;
}
  expression = parseUnaliasedExpression
  (
    < AS > 
    objectIdentifier = parseIdentifier
    {
      CompoundId compoundId = new CompoundIdR(List.of(objectIdentifier));
      expression = new CallExpressionR("AS", CallExpression.Type.TERM_INFIX, List.of(
      expression, compoundId
      )
      );
    }
  )*
  {
    return expression;
  }
;


Expression parseExpressionOrEmpty :
{
  Expression expression;
}
  expression = parseExpression
  {
    return expression;
  }
| /* empty */
  {
    return new CallExpressionR("", CallExpression.Type.EMPTY, List.of()
    );
  }
;


// Comma-separated list of expressions, some of which may be empty. Used
// for functions.
List < Expression > expOrEmptyList :
{
  Expression expression;
  List < Expression > list = new LinkedList<>();
}
  expression = parseExpressionOrEmpty
  {
    list.add(expression);
  }
  (
    < COMMA >
    expression = parseExpressionOrEmpty
    {
      list.add(expression);
    }
  )*
  {
    return list;
  }
;


// List of expressions, none of which may be empty.
List < Expression > expList :
{
  Expression expression;
  List < Expression > list = new LinkedList<>();
}
  expression = parseExpression
  {
    list.add(expression);
  }
  (
    < COMMA >
    expression = parseExpression
    {
      list.add(expression);
    }
  )*
  {
    return list;
  }
;


Expression parseExpressionEof :
{
  Expression expression;
}
  expression = parseExpression < EOF >
  {
    return expression;
  }
;


ObjectIdentifier parseIdentifier#void :
{
  ObjectIdentifier objectIdentifier;
}
  (
    objectIdentifier = parseNameObjectIdentifier
    |
    objectIdentifier = parseKeyIdentifier
  )
  {
    return objectIdentifier;
  }
;

INJECT ASTNameObjectIdentifier :
  implements org.eclipse.daanse.mdx.model.api.expression.SymbolLiteral,
             org.eclipse.daanse.mdx.model.api.expression.NameObjectIdentifier
{
  @Property Quoting quoting = Quoting.UNQUOTED;
  @Property String name;
  public Quoting quoting() {return getQuoting();}
  public String name() {return getName();}
  public String value() {return getName();}
}

NameObjectIdentifier parseNameObjectIdentifier#NameObjectIdentifier :
 (
  parseKeyword {CURRENT_NODE.setName(getTokenImage(0));}
  |
  < ID > {CURRENT_NODE.setName(getTokenImage(0));}
  |
  < ATSIGN > < ID > { CURRENT_NODE.setName("@" + getTokenImage(0)); }
  | 
  < QUOTED_ID >
  {
    String name = stripQuotes(getTokenImage(0), "[", "]", "]]");
    CURRENT_NODE.setName(name);
    CURRENT_NODE.setQuoting(ObjectIdentifier.Quoting.QUOTED);
  }
 )
 {return CURRENT_NODE;}
;


INJECT ASTKeyObjectIdentifier :
   import java.util.List;
   import java.util.ArrayList;
   import org.eclipse.daanse.mdx.model.api.expression.NameObjectIdentifier;
   implements org.eclipse.daanse.mdx.model.api.expression.KeyObjectIdentifier
{
   public List<NameObjectIdentifier> nameObjectIdentifiers() {
     return childrenOfType(NameObjectIdentifier.class);
   }

   @Override
   public Quoting quoting() {
       return Quoting.KEY;
   }
}

// for example '&foo&[1]&bar' in '[x].&foo&[1]&bar.[y]'
KeyObjectIdentifier parseKeyIdentifier#KeyObjectIdentifier :
  ( parseAmpId )+
  {
    return CURRENT_NODE;
  }
;


NameObjectIdentifier parseAmpId#NameObjectIdentifier :
 (
  < AMP_QUOTED_ID >
  {
    String name = stripQuotes(getTokenImage(0), "&[", "]", "]]");
    CURRENT_NODE.setName(name);
    CURRENT_NODE.setQuoting(ObjectIdentifier.Quoting.QUOTED);
  }
  |
  < AMP_UNQUOTED_ID >
  {
    CURRENT_NODE.setName(getTokenImage(0).substring(1));
  }
 )
 {return CURRENT_NODE;}
;


// a keyword that is not a RESERVED_WORD could be used as identifier
String parseKeyword :
  (
    < DIMENSION >
  | < PROPERTIES >
  )
  {
    return getTokenImage(0);
  }
;

INJECT ASTCompoundId :
  import java.util.List;
  import java.util.ArrayList;
  import org.eclipse.daanse.mdx.model.api.expression.ObjectIdentifier;
  implements org.eclipse.daanse.mdx.model.api.expression.CompoundId
{
    public List<ObjectIdentifier> objectIdentifiers() {
       return childrenOfType(ObjectIdentifier.class);
    }
}  

parseCompoundId#CompoundId :
  parseIdentifier
  (
    < DOT > parseIdentifier
  )*
;


// ----------------------------------------------------------------------------
// Expressions
Expression parseUnaliasedExpression :
{
  Expression x;
  Expression y;
}
  x = parseTerm5
  (
    < OR > y = parseTerm5
    {
      x = new CallExpressionR("OR", CallExpression.Type.TERM_INFIX, List.of(
      x, y
      )
      );
    }
    | 
    < XOR > y = parseTerm5
    {
      x = new CallExpressionR("XOR", CallExpression.Type.TERM_INFIX, List.of(
      x, y
      )
      );
    }
    |
    // range 'm1 : m2' yields set of members
    < COLON > y = parseTerm5
    {
      x = new CallExpressionR(":", CallExpression.Type.TERM_INFIX, List.of(
      x, y
      )
      );
    }
  )*
  {
    return x;
  }
;


Expression parseTerm5 :
{
  Expression x;
  Expression y;
}
  x = parseTerm4
  (
    < AND > y = parseTerm4
    {
      x = new CallExpressionR("AND", CallExpression.Type.TERM_INFIX, List.of(
      x, y
      )
      );
    }
  )*
  {
    return x;
  }
;


Expression parseTerm4 :
{
  Expression x;
}
  x = parseTerm3
  {
    return x;
  }
  | 
  < NOT > x = parseTerm4
  {
    return new CallExpressionR("NOT", CallExpression.Type.TERM_PREFIX, List.of(
    x
    )
    );
  }
;


Expression parseTerm3 :
{
  Expression x;
  Expression y;
  Token op;
}
  x = parseTerm2
  (
    // e.g. "1 < 5"
    (
      < EQ >
      {
        op = getToken(0);
      }
    | < NE >
      {
        op = getToken(0);
      }
    | < LT >
      {
        op = getToken(0);
      }
    | < GT >
      {
        op = getToken(0);
      }
    | < LE >
      {
        op = getToken(0);
      }
    | < GE >
      {
        op = getToken(0);
      }
    )
    y = parseTerm2
    {
      x = new CallExpressionR(op.getImage(), CallExpression.Type.TERM_INFIX, List.of(
      x, y
      )
      );
    }
  |
    // We expect a shift-reduce conflict here, because NULL is a literal and
    // so is a valid argument to the IS operator. We want to shift.
    SCAN 2 =>
    < IS > < NULL >
    {
      x = new CallExpressionR("IS NULL", CallExpression.Type.TERM_POSTFIX, List.of(
      x
      )
      );
    }
  |
    // e.g. "x IS y"; but "x IS NULL" is handled elsewhere
    SCAN 2 =>
    < IS > y = parseTerm2
    {
      x = new CallExpressionR("IS", CallExpression.Type.TERM_INFIX, List.of(
      x, y
      )
      );
    }
  | < IS > < EMPTY >
    {
      x = new CallExpressionR(
      "IS EMPTY", CallExpression.Type.TERM_POSTFIX, List.of(x));
    }
  | < MATCHES > y = parseTerm2
    {
      x = new CallExpressionR("MATCHES", CallExpression.Type.TERM_INFIX, List.of(
      x, y
      )
      );
    }
  | SCAN 2 =>
    < NOT > < MATCHES > y = parseTerm2
    {
      x = new CallExpressionR(
      "NOT", CallExpression.Type.TERM_PREFIX, List.of(
      new CallExpressionR(
      "MATCHES", CallExpression.Type.TERM_INFIX, List.of(
      x, y
      )
      )
      )
      );
    }
  | < IN > y = parseTerm2
    {
      x = new CallExpressionR("IN", CallExpression.Type.TERM_INFIX, List.of(
      x, y
      )
      );
    }
  | < NOT > < IN > y = parseTerm2
    {
      x = new CallExpressionR(
      "NOT", CallExpression.Type.TERM_PREFIX, List.of(
      new CallExpressionR(
      "IN", CallExpression.Type.TERM_INFIX, List.of(
      x, y
      )
      )
      )
      );
    }
  )*
  {
    return x;
  }
;


Expression parseTerm2 :
{
  Expression x;
  Expression y;
}
  x = parseTerm
  (
    < PLUS > y = parseTerm
    {
      x = new CallExpressionR("+", CallExpression.Type.TERM_INFIX, List.of(
      x, y
      )
      );
    }
  | < MINUS > y = parseTerm
    {
      x = new CallExpressionR("-", CallExpression.Type.TERM_INFIX, List.of(
      x, y
      )
      );
    }
  | < CONCAT > y = parseTerm
    {
      x = new CallExpressionR("||", CallExpression.Type.TERM_INFIX, List.of(
      x, y
      )
      );
    }
  )*
  {
    return x;
  }
;


Expression parseTerm :
{
  Expression x;
  Expression y;
}
  x = parseFactor
  (
    < ASTERISK > y = parseFactor
    {
      x = new CallExpressionR("*", CallExpression.Type.TERM_INFIX, List.of(
      x, y
      )
      );
    }
  | < SOLIDUS > y = parseFactor
    {
      x = new CallExpressionR("/", CallExpression.Type.TERM_INFIX, List.of(
      x, y
      )
      );
    }
  )*
  {
    return x;
  }
;


Expression parseFactor :
{
  Expression p;
}
  p = parsePrimary
  {
    return p;
  }
| < PLUS > p = parsePrimary
  {
    return p;
  }
| < MINUS > p = parsePrimary
  {
    return new CallExpressionR("-", CallExpression.Type.TERM_PREFIX, List.of(
    p
    )
    );
  }
| < EXISTING > p = parsePrimary
  {
    return new CallExpressionR("Existing", CallExpression.Type.TERM_PREFIX, List.of(
    p
    )
    );
  }
;

INJECT ASTPrimaryExpression : implements org.eclipse.daanse.mdx.model.api.expression.Expression

Expression parsePrimary#PrimaryExpression :
{
  Expression expression;
}
  expression = parseAtom
  (
    < DOT > expression = objectIdentifierOrFuncall(expression)
  )*
  {
    return CURRENT_NODE;
  }
;

Expression objectIdentifierOrFuncall(Expression left) :
{
  ObjectIdentifier objectIdentifier;
  List < Expression > argList = null;
}
  objectIdentifier = parseIdentifier
  (
    < LPAREN >
    (
      argList = expOrEmptyList
    )
    < RPAREN >
  )?
  {
    return createCall(left, objectIdentifier, argList);
  }
;

parseLiteral#void :
  <SINGLE_QUOTED_STRING>
  |
  <DOUBLE_QUOTED_STRING>
  |
  <UNSIGNED_INTEGER_LITERAL>
  |
  <DECIMAL_NUMERIC_LITERAL>
  |
  <APPROX_NUMERIC_LITERAL>
  |
  <NULL>
;

INJECT ASTCastExpression :
   import java.util.List;
   import org.eclipse.daanse.mdx.model.api.expression.Expression;
   import org.eclipse.daanse.mdx.model.api.expression.NameObjectIdentifier;
   import org.eclipse.daanse.mdx.model.api.expression.CallExpression.Type;
   implements org.eclipse.daanse.mdx.model.api.expression.CallExpression
{
    @Property Expression expression;

    public String name() {
      return "CAST";
    }

    public Type type() {
      return Type.CAST;
    }

    public List<Expression> expressions() {
      NameObjectIdentifier noi = firstChildOfType(NameObjectIdentifier.class);
      return List.of(getExpression(), noi);
    }
}

Expression parseCastExpression#CastExpression :
{
  Expression expression;
}
  <CAST>
  <LPAREN>
  expression = parseUnaliasedExpression
  {CURRENT_NODE.setExpression(expression);}
  <AS>
  parseNameObjectIdentifier 
  <RPAREN>
  {
    return CURRENT_NODE;
  }
;

Expression parseExpressionList#void :
{
   List<Expression> expressions;
}
  < LPAREN > expressions = expList < RPAREN >
  {
    // Whereas ([Sales],[Time]) and () are tuples, ([Sales]) and (5)
    // are just expressions.
    return new CallExpressionR(
    "()", CallExpression.Type.PARENTHESES, expressions);
  }
;

Expression parseTuple#void :
{
   List<Expression> expressions;
}
  // set built from sets/tuples
  < LBRACE >
  (
    SCAN < RBRACE > =>
    {
      expressions = Collections.emptyList();
    }
    |
    expressions = expList
  )
  < RBRACE >
  {
    return new CallExpressionR(
    "{}", CallExpression.Type.BRACES, expressions);
  }
;

Expression parseOnlyName#void :
   parseNameObjectIdentifier ASSERT ~(<BANG>|<LPAREN>) =>||
   {
      return (Expression) peekNode();
   }
;

Expression parseMaybeBangMaybeFunctionCall#void :
  // Function call "foo(a, b)" or "whiz!bang!foo(a, b)".
  // Properties "x.PROP" and methods "exp.meth(a)" are in primary().
{
  Expression expression;
  NameObjectIdentifier nameObjectIdentifier;
  List < Expression > expressions = null;
}
  nameObjectIdentifier = parseNameObjectIdentifier
  (
    < BANG > nameObjectIdentifier = parseNameObjectIdentifier
    {
    // We support the syntax for qualifying function names with package
    // names separated by bang ('!'), e.g. 'whiz!bang!foo(a, b)'
    // but currently we ignore the qualifiers. The previous example is
    // equivalent to 'foo(a, b)'.
    }
  )*
  (
    < LPAREN >
    (
      SCAN < RPAREN > =>
      {
        expressions = Collections.emptyList();
      }
      |
      expressions = expOrEmptyList
    )
    < RPAREN >
  )?
  {
    return createCall(null, nameObjectIdentifier, expressions);
  }
;

Expression parseAtom :
{
  Expression expression;
}
  (
    parseLiteral {expression = (Expression) lastConsumedToken;}
    | 
    expression=parseCastExpression
    |
    expression=parseExpressionList
    | 
    expression=parseTuple 
    | 
    expression = parseCaseExpression 
    |
    expression = parseOnlyName 
    |
    expression = parseMaybeBangMaybeFunctionCall
  )
  {
    return expression;
  }
;


Expression parseCaseExpression#void :
{
  Expression expression, expression2;
  List < Expression > expressions = new ArrayList <> ();
  boolean match = false;
}
  < CASE >
  (
    expression = parseExpression
    {
      match = true;
      expressions.add(expression);
    }
  )?
  (
    < WHEN > expression = parseExpression < THEN > expression2 = parseExpression
    {
      expressions.add(expression);
      expressions.add(expression2);
    }
  )*
  (
    < ELSE > expression = parseExpression
    {
      expressions.add(expression);
    }
  )?
  < END >
  {
    if (match)
    {
      return new CallExpressionR(
      "_CaseMatch", CallExpression.Type.TERM_CASE, expressions);
    }
    else
    {
      return new CallExpressionR(
      "_CaseTest", CallExpression.Type.TERM_CASE, expressions);
    }
  }
;

INJECT ASTCreateSetBodyClause :
  import org.eclipse.daanse.mdx.model.api.expression.CompoundId;
  import org.eclipse.daanse.mdx.model.api.expression.Expression;
  implements org.eclipse.daanse.mdx.model.api.select.CreateSetBodyClause
{
   public CompoundId compoundId() {
      return (CompoundId) getChild(0);
   }

   public Expression expression() {
      return (Expression) getChild(2);
   }
}  

CreateSetBodyClause parseCreateSetBodyClause#CreateSetBodyClause :
  parseCompoundId < AS > parseExpression
  {
    return CURRENT_NODE;
  }
;


INJECT ASTSelectDimensionPropertyListClause :
   import java.util.List;
   import org.eclipse.daanse.mdx.model.api.expression.CompoundId;
   implements org.eclipse.daanse.mdx.model.api.select.SelectDimensionPropertyListClause
{
  public List<CompoundId> properties() {
     return childrenOfType(CompoundId.class);
  }
}

parseSelectDimensionPropertyListClause#SelectDimensionPropertyListClause :
  (< DIMENSION >)?
  < PROPERTIES >
  parseCompoundId
  (
    < COMMA >
    parseCompoundId
  )*
;

INJECT ASTRefreshStatement :
   import org.eclipse.daanse.mdx.model.api.expression.NameObjectIdentifier;
   implements org.eclipse.daanse.mdx.model.api.RefreshStatement;
{
   public NameObjectIdentifier cubeName() {
      return (NameObjectIdentifier) getChild(2);
   }
}

RefreshStatement parseRefreshStatement#RefreshStatement :
  < REFRESH > 
  < CUBE >  
  parseNameObjectIdentifier
  {
     return CURRENT_NODE;
  }
;

INJECT ASTDMVStatement :
   import java.util.List;
   import org.eclipse.daanse.mdx.model.api.expression.NameObjectIdentifier;
   import org.eclipse.daanse.mdx.model.api.expression.CompoundId;
   import org.eclipse.daanse.mdx.model.api.expression.Expression;
   implements org.eclipse.daanse.mdx.model.api.DMVStatement;
{
    public List<CompoundId> columns() {
        return childrenOfType(CompoundId.class);
    }

    public NameObjectIdentifier table() {
       return (NameObjectIdentifier) firstChildOfType(DOT).nextSibling();
    }

    public Expression where() {
        Node where = firstChildOfType(WHERE);
        return where == null ? null
                             : (Expression) where.nextSibling();
    }
}

DMVStatement parseDMVStatement#DMVStatement :
  < SELECT >
  (
    parseCompoundId
    (
        < COMMA > parseCompoundId
    )*
  )?
  < FROM > 
  < SYSTEM_CUBE >
  < DOT > 
  parseNameObjectIdentifier
  (
     < WHERE > parseExpression()
  )?
  {
     return CURRENT_NODE;
  }
;

INJECT ASTSelectQueryAxisClause :
   import org.eclipse.daanse.mdx.model.api.expression.Expression;
   import org.eclipse.daanse.mdx.model.api.select.Axis;
   import org.eclipse.daanse.mdx.model.api.select.SelectDimensionPropertyListClause;
   implements org.eclipse.daanse.mdx.model.api.select.SelectQueryAxisClause
{
    public boolean nonEmpty() {
       return getChild(0).getType() == NON && getChild(1).getType() == EMPTY;
    }

    public Expression expression() {
    //TODO
      return null;
    };

    public Axis axis() {
    //TODO
       return null;
    };

    public SelectDimensionPropertyListClause selectDimensionPropertyListClause() {
       return firstChildOfType(SelectDimensionPropertyListClause.class);
    }
}

// <SelectQueryAxisClause> ::= [NON EMPTY] <set> [<dimProps>] ON <axis_name>
SelectQueryAxisClause parseSelectQueryAxisClause#SelectQueryAxisClause :
  (< NON > < EMPTY >) ?
  parseExpression
  (
    parseSelectDimensionPropertyListClause
  )?
  < ON >
  (
    (
      < UNSIGNED_INTEGER_LITERAL >
      | 
      < AXIS >
      < LPAREN > 
      < UNSIGNED_INTEGER_LITERAL >
      < RPAREN >
    )
    |
    (
      < COLUMNS >
      | 
      < ROWS >
      | 
      < PAGES >
      | 
      < SECTIONS >
      | 
      < CHAPTERS >
    )
  )
  {
    return CURRENT_NODE;
  }
;

